//! # gm-analysis
//!
//! Security analysis engine for Kusanagi Kajiki.
//!
//! ## Modules
//!
//! - **attack**: MITRE ATT&CK for ICS technique detection
//! - **purdue**: Purdue Model auto-assignment and violation detection
//! - **anomaly**: Anomaly scoring for network behavior deviations
//!
//! ## Architecture
//!
//! All analysis functions take immutable snapshots of application state
//! (assets, connections, deep parse info) and produce findings/assignments.
//! They never modify state directly — the caller (commands layer) merges
//! results back into AppState.

pub mod attack;
pub mod purdue;
pub mod anomaly;
pub mod error;

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::Utc;

/// A security finding produced by analysis.
///
/// Findings are generated by ATT&CK detection, Purdue violation checks,
/// and anomaly scoring. They are stored in the DB findings table and
/// displayed in the FindingsPanel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Finding {
    pub id: String,
    pub finding_type: FindingType,
    pub severity: Severity,
    pub title: String,
    pub description: String,
    /// IPs of affected assets
    pub affected_assets: Vec<String>,
    /// Human-readable evidence explaining why this was flagged
    pub evidence: String,
    /// MITRE ATT&CK technique ID (e.g., "T0855"), if applicable
    pub technique_id: Option<String>,
    /// When this finding was generated
    pub created_at: String,
}

impl Finding {
    pub fn new(
        finding_type: FindingType,
        severity: Severity,
        title: String,
        description: String,
        affected_assets: Vec<String>,
        evidence: String,
        technique_id: Option<String>,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            finding_type,
            severity,
            title,
            description,
            affected_assets,
            evidence,
            technique_id,
            created_at: Utc::now().to_rfc3339(),
        }
    }
}

/// Type classification for findings.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum FindingType {
    /// MITRE ATT&CK for ICS technique detection
    AttackTechnique,
    /// Purdue Model cross-level violation
    PurdueViolation,
    /// Network behavior anomaly
    Anomaly,
}

/// Severity level for findings and anomalies.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
#[serde(rename_all = "snake_case")]
pub enum Severity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

impl Severity {
    pub fn as_str(&self) -> &'static str {
        match self {
            Severity::Info => "info",
            Severity::Low => "low",
            Severity::Medium => "medium",
            Severity::High => "high",
            Severity::Critical => "critical",
        }
    }
}

/// Purdue level assignment for a device.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PurdueAssignment {
    pub ip_address: String,
    pub level: u8,
    /// How the level was determined
    pub method: PurdueMethod,
    /// Reasoning for the assignment
    pub reason: String,
}

/// How a Purdue level was assigned.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PurdueMethod {
    /// Auto-assigned based on device classification
    Auto,
    /// Manually overridden by user
    Manual,
}

/// An anomaly detected in network behavior.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnomalyScore {
    pub anomaly_type: AnomalyType,
    pub severity: Severity,
    /// Confidence in this anomaly detection (0.0 - 1.0)
    pub confidence: f64,
    pub affected_asset: String,
    pub evidence: String,
}

/// Types of network anomalies detected.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum AnomalyType {
    /// Polling interval deviates significantly from baseline
    PollingDeviation,
    /// Slave/outstation sending unsolicited data to non-master
    RoleReversal,
    /// New device appeared on OT subnet
    NewDevice,
    /// Public IP on OT network
    UnexpectedPublicIp,
}

/// Input data for analysis — a snapshot of the current state.
///
/// This is constructed from AppStateInner fields and passed
/// to analysis functions. Avoids coupling gm-analysis to Tauri.
#[derive(Debug, Clone, Default)]
pub struct AnalysisInput {
    pub assets: Vec<AssetSnapshot>,
    pub connections: Vec<ConnectionSnapshot>,
    pub deep_parse: std::collections::HashMap<String, DeepParseSnapshot>,
}

/// Minimal asset data needed for analysis.
#[derive(Debug, Clone)]
pub struct AssetSnapshot {
    pub ip_address: String,
    pub device_type: String,
    pub protocols: Vec<String>,
    pub purdue_level: Option<u8>,
    pub is_public_ip: bool,
    pub tags: Vec<String>,
    pub vendor: Option<String>,
}

/// Minimal connection data needed for analysis.
#[derive(Debug, Clone)]
pub struct ConnectionSnapshot {
    pub src_ip: String,
    pub dst_ip: String,
    pub src_port: u16,
    pub dst_port: u16,
    pub protocol: String,
    pub packet_count: u64,
}

/// Deep parse data snapshot for analysis.
#[derive(Debug, Clone, Default)]
pub struct DeepParseSnapshot {
    pub modbus: Option<ModbusSnapshot>,
    pub dnp3: Option<Dnp3Snapshot>,
}

/// Modbus data needed for ATT&CK detection.
#[derive(Debug, Clone)]
pub struct ModbusSnapshot {
    pub role: String,
    pub unit_ids: Vec<u8>,
    pub function_codes: Vec<FcSnapshot>,
    pub relationships: Vec<RelationshipSnapshot>,
    pub polling_intervals: Vec<PollingSnapshot>,
}

/// DNP3 data needed for ATT&CK detection.
#[derive(Debug, Clone)]
pub struct Dnp3Snapshot {
    pub role: String,
    pub has_unsolicited: bool,
    pub function_codes: Vec<FcSnapshot>,
    pub relationships: Vec<RelationshipSnapshot>,
}

/// Function code usage data.
#[derive(Debug, Clone)]
pub struct FcSnapshot {
    pub code: u8,
    pub count: u64,
    pub is_write: bool,
}

/// Relationship data (master/slave or master/outstation).
#[derive(Debug, Clone)]
pub struct RelationshipSnapshot {
    pub remote_ip: String,
    pub remote_role: String,
    pub packet_count: u64,
}

/// Polling interval data for anomaly detection.
#[derive(Debug, Clone)]
pub struct PollingSnapshot {
    pub remote_ip: String,
    pub function_code: u8,
    pub avg_interval_ms: f64,
    pub min_interval_ms: f64,
    pub max_interval_ms: f64,
    pub sample_count: u64,
}

/// Full analysis result combining all modules.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisResult {
    pub findings: Vec<Finding>,
    pub purdue_assignments: Vec<PurdueAssignment>,
    pub anomalies: Vec<AnomalyScore>,
    /// Summary statistics
    pub summary: AnalysisSummary,
}

/// Summary statistics from an analysis run.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisSummary {
    pub total_findings: usize,
    pub critical_count: usize,
    pub high_count: usize,
    pub medium_count: usize,
    pub low_count: usize,
    pub info_count: usize,
    pub purdue_violations: usize,
    pub anomaly_count: usize,
    pub assets_analyzed: usize,
    pub connections_analyzed: usize,
    /// Percentage of traffic that is unencrypted OT
    pub unencrypted_ot_percent: f64,
}

/// Run the full analysis pipeline.
///
/// This is the main entry point — it calls all three analysis modules
/// and combines their results.
pub fn run_full_analysis(input: &AnalysisInput) -> AnalysisResult {
    // Run ATT&CK detection
    let attack_findings = attack::detect_attack_techniques(input);

    // Run Purdue auto-assignment
    let purdue_assignments = purdue::auto_assign_purdue_levels(input);

    // Run Purdue violation detection (needs assignments)
    let purdue_findings = purdue::detect_purdue_violations(input, &purdue_assignments);

    // Run anomaly detection
    let (anomalies, anomaly_findings) = anomaly::detect_anomalies(input);

    // Combine all findings
    let mut findings = Vec::new();
    findings.extend(attack_findings);
    findings.extend(purdue_findings);
    findings.extend(anomaly_findings);

    // Sort by severity (critical first)
    findings.sort_by(|a, b| b.severity.cmp(&a.severity));

    // Compute unencrypted OT percentage
    let total_ot_packets: u64 = input.connections.iter()
        .filter(|c| is_ot_protocol(&c.protocol))
        .map(|c| c.packet_count)
        .sum();
    let encrypted_ot_packets: u64 = input.connections.iter()
        .filter(|c| c.protocol == "Https" || c.protocol == "Ssh")
        .map(|c| c.packet_count)
        .sum();
    let unencrypted_ot_percent = if total_ot_packets > 0 {
        let unencrypted = total_ot_packets.saturating_sub(encrypted_ot_packets);
        (unencrypted as f64 / total_ot_packets as f64) * 100.0
    } else {
        0.0
    };

    // Build summary
    let summary = AnalysisSummary {
        total_findings: findings.len(),
        critical_count: findings.iter().filter(|f| f.severity == Severity::Critical).count(),
        high_count: findings.iter().filter(|f| f.severity == Severity::High).count(),
        medium_count: findings.iter().filter(|f| f.severity == Severity::Medium).count(),
        low_count: findings.iter().filter(|f| f.severity == Severity::Low).count(),
        info_count: findings.iter().filter(|f| f.severity == Severity::Info).count(),
        purdue_violations: findings.iter().filter(|f| f.finding_type == FindingType::PurdueViolation).count(),
        anomaly_count: anomalies.len(),
        assets_analyzed: input.assets.len(),
        connections_analyzed: input.connections.len(),
        unencrypted_ot_percent: (unencrypted_ot_percent * 10.0).round() / 10.0,
    };

    AnalysisResult {
        findings,
        purdue_assignments,
        anomalies,
        summary,
    }
}

/// Check if a protocol string represents an OT protocol.
fn is_ot_protocol(proto: &str) -> bool {
    matches!(
        proto,
        "Modbus" | "Dnp3" | "EthernetIp" | "Bacnet" | "S7comm"
            | "OpcUa" | "Profinet" | "Iec104" | "Mqtt" | "HartIp"
            | "FoundationFieldbus" | "GeSrtp" | "WonderwareSuitelink"
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
        assert!(Severity::Low > Severity::Info);
    }

    #[test]
    fn test_finding_new() {
        let f = Finding::new(
            FindingType::AttackTechnique,
            Severity::High,
            "Test".to_string(),
            "Description".to_string(),
            vec!["10.0.0.1".to_string()],
            "Evidence".to_string(),
            Some("T0855".to_string()),
        );
        assert!(!f.id.is_empty());
        assert_eq!(f.severity, Severity::High);
        assert_eq!(f.technique_id, Some("T0855".to_string()));
    }

    #[test]
    fn test_empty_analysis() {
        let input = AnalysisInput::default();
        let result = run_full_analysis(&input);
        assert_eq!(result.findings.len(), 0);
        assert_eq!(result.purdue_assignments.len(), 0);
        assert_eq!(result.anomalies.len(), 0);
        assert_eq!(result.summary.total_findings, 0);
    }

    #[test]
    fn test_is_ot_protocol() {
        assert!(is_ot_protocol("Modbus"));
        assert!(is_ot_protocol("Dnp3"));
        assert!(is_ot_protocol("S7comm"));
        assert!(!is_ot_protocol("Http"));
        assert!(!is_ot_protocol("Unknown"));
    }
}
